import { Contract as IWeb3Contract, ContractSendMethod as Web3Method } from 'web3-eth-contract';
import Web3Utils from 'web3-utils';
import Web3 from 'web3';

import Big from './types/big';
import ITx from './types/ITx';

const AbiCoder = require('web3-eth-abi');
const Web3Contract = require('web3-eth-contract');

type IWeb3Response = { [key: string]: any };

/**
 * The ordinary `web3.eth.Contract(...)` implementation uses `web3.currentProvider`
 * to make blockchain calls and sends convenient. This class extricates the notion
 * of a Provider from that of a Contract, allowing contracts to be instantiated
 * at any point in the code -- no need to first setup a web3 provider.
 *
 * That said, the ordinary `web3.eth.Contract(...)` should be used when subscribing
 * to events and/or retrieving past events because the API is clear and will notify
 * listeners if an on-chain event was rolled back by a chain fork.
 */
export default abstract class Contract {
  public readonly address: string;

  protected readonly abi: Web3Utils.AbiItem[];

  protected readonly inner: IWeb3Contract;

  /**
   * Constructs a new Contract instance
   *
   * @param address the address (0x123abc...) of the deployed contract
   * @param abi the abi of the deployed contract, generated by compiler
   */
  constructor(address: string, abi: Web3Utils.AbiItem[]) {
    this.address = address;
    this.abi = abi;
    this.inner = new Web3Contract(abi, address);
  }

  /**
   * Returns an async function that can fetch return data from any Solidity `method`
   * whose return type is uint256
   *
   * @param method the Solidity method to call (with input params)
   * @param modifier function that applies post-processing after fetching
   */
  protected callerForUint256(method: Web3Method, modifier = (x: Big): any => x) {
    return this.callerFor(method, ['uint256'], (x) => modifier(Big(x['0'])));
  }

  /**
   * Returns an async function that can fetch return data from any Solidity `method`
   *
   * @param method the Solidity method to call (with input params)
   * @param outputTypes array of Solidity return types, e.g. 'uint256'
   * @param modifier function that applies post-processing after fetching
   */
  protected callerFor(method: Web3Method, outputTypes: string[], modifier = (x: IWeb3Response): any => x) {
    return async (provider: Web3, block = 'latest') => {
      const x = await provider.eth.call(
        {
          to: this.address,
          data: method.encodeABI(),
        },
        block,
      );
      return modifier(AbiCoder.decodeParameters(outputTypes, x));
    };
  }

  /**
   * Returns a sendable transaction object that will call `method`
   *
   * @param method the Solidity method that you want to run on-chain
   * @param gasLimit maximum gas to spend running the method
   * @param gasPrice Wei to spend per gas unit
   */
  protected txFor(method: Web3Method, gasLimit = Big('0'), gasPrice = Big('0')): ITx {
    return {
      gasPrice,
      gasLimit,
      to: this.address,
      data: method.encodeABI(),
    };
  }

  protected storageAt(slot: string, modifier = (x: string): any => x) {
    return async (provider: Web3, block = 'latest') => {
      const x = await provider.eth.getStorageAt(this.address, slot, block);
      return modifier(x);
    };
  }
}
